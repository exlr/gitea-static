var se=Object.defineProperty,ne=Object.defineProperties;var ae=Object.getOwnPropertyDescriptors;var L=Object.getOwnPropertySymbols;var oe=Object.prototype.hasOwnProperty,ie=Object.prototype.propertyIsEnumerable;var M=(f,h,l)=>h in f?se(f,h,{enumerable:!0,configurable:!0,writable:!0,value:l}):f[h]=l,P=(f,h)=>{for(var l in h||(h={}))oe.call(h,l)&&M(f,l,h[l]);if(L)for(var l of L(h))ie.call(h,l)&&M(f,l,h[l]);return f},U=(f,h)=>ne(f,ae(h));var c=(f,h,l)=>new Promise((A,p)=>{var x=w=>{try{$(l.next(w))}catch(d){p(d)}},b=w=>{try{$(l.throw(w))}catch(d){p(d)}},$=w=>w.done?A(w.value):Promise.resolve(w.value).then(x,b);$((l=l.apply(f,h)).next())});(function(){"use strict";var f={"./node_modules/workbox-core/_version.js":function(){try{self["workbox:core:6.1.5"]&&_()}catch(p){}},"./node_modules/workbox-routing/_version.js":function(){try{self["workbox:routing:6.1.5"]&&_()}catch(p){}},"./node_modules/workbox-strategies/_version.js":function(){try{self["workbox:strategies:6.1.5"]&&_()}catch(p){}}},h={};function l(p){var x=h[p];if(x!==void 0)return x.exports;var b=h[p]={exports:{}};return f[p](b,b.exports,l),b.exports}var A={};(function(){var p=l("./node_modules/workbox-core/_version.js");const x={"invalid-value":({paramName:r,validValueDescription:e,value:t})=>{if(!r||!e)throw new Error("Unexpected input to 'invalid-value' error.");return`The '${r}' parameter was given a value with an unexpected value. ${e} Received a value of ${JSON.stringify(t)}.`},"not-an-array":({moduleName:r,className:e,funcName:t,paramName:s})=>{if(!r||!e||!t||!s)throw new Error("Unexpected input to 'not-an-array' error.");return`The parameter '${s}' passed into '${r}.${e}.${t}()' must be an array.`},"incorrect-type":({expectedType:r,paramName:e,moduleName:t,className:s,funcName:n})=>{if(!r||!e||!t||!n)throw new Error("Unexpected input to 'incorrect-type' error.");return`The parameter '${e}' passed into '${t}.${s?s+".":""}${n}()' must be of type ${r}.`},"incorrect-class":({expectedClass:r,paramName:e,moduleName:t,className:s,funcName:n,isReturnValueProblem:o})=>{if(!r||!t||!n)throw new Error("Unexpected input to 'incorrect-class' error.");return o?`The return value from '${t}.${s?s+".":""}${n}()' must be an instance of class ${r.name}.`:`The parameter '${e}' passed into '${t}.${s?s+".":""}${n}()' must be an instance of class ${r.name}.`},"missing-a-method":({expectedMethod:r,paramName:e,moduleName:t,className:s,funcName:n})=>{if(!r||!e||!t||!s||!n)throw new Error("Unexpected input to 'missing-a-method' error.");return`${t}.${s}.${n}() expected the '${e}' parameter to expose a '${r}' method.`},"add-to-cache-list-unexpected-type":({entry:r})=>`An unexpected entry was passed to 'workbox-precaching.PrecacheController.addToCacheList()' The entry '${JSON.stringify(r)}' isn't supported. You must supply an array of strings with one or more characters, objects with a url property or Request objects.`,"add-to-cache-list-conflicting-entries":({firstEntry:r,secondEntry:e})=>{if(!r||!e)throw new Error("Unexpected input to 'add-to-cache-list-duplicate-entries' error.");return`Two of the entries passed to 'workbox-precaching.PrecacheController.addToCacheList()' had the URL ${r._entryId} but different revision details. Workbox is unable to cache and version the asset correctly. Please remove one of the entries.`},"plugin-error-request-will-fetch":({thrownError:r})=>{if(!r)throw new Error("Unexpected input to 'plugin-error-request-will-fetch', error.");return`An error was thrown by a plugins 'requestWillFetch()' method. The thrown error message was: '${r.message}'.`},"invalid-cache-name":({cacheNameId:r,value:e})=>{if(!r)throw new Error("Expected a 'cacheNameId' for error 'invalid-cache-name'");return`You must provide a name containing at least one character for setCacheDetails({${r}: '...'}). Received a value of '${JSON.stringify(e)}'`},"unregister-route-but-not-found-with-method":({method:r})=>{if(!r)throw new Error("Unexpected input to 'unregister-route-but-not-found-with-method' error.");return`The route you're trying to unregister was not  previously registered for the method type '${r}'.`},"unregister-route-route-not-registered":()=>"The route you're trying to unregister was not previously registered.","queue-replay-failed":({name:r})=>`Replaying the background sync queue '${r}' failed.`,"duplicate-queue-name":({name:r})=>`The Queue name '${r}' is already being used. All instances of backgroundSync.Queue must be given unique names.`,"expired-test-without-max-age":({methodName:r,paramName:e})=>`The '${r}()' method can only be used when the '${e}' is used in the constructor.`,"unsupported-route-type":({moduleName:r,className:e,funcName:t,paramName:s})=>`The supplied '${s}' parameter was an unsupported type. Please check the docs for ${r}.${e}.${t} for valid input types.`,"not-array-of-class":({value:r,expectedClass:e,moduleName:t,className:s,funcName:n,paramName:o})=>`The supplied '${o}' parameter must be an array of '${e}' objects. Received '${JSON.stringify(r)},'. Please check the call to ${t}.${s}.${n}() to fix the issue.`,"max-entries-or-age-required":({moduleName:r,className:e,funcName:t})=>`You must define either config.maxEntries or config.maxAgeSecondsin ${r}.${e}.${t}`,"statuses-or-headers-required":({moduleName:r,className:e,funcName:t})=>`You must define either config.statuses or config.headersin ${r}.${e}.${t}`,"invalid-string":({moduleName:r,funcName:e,paramName:t})=>{if(!t||!r||!e)throw new Error("Unexpected input to 'invalid-string' error.");return`When using strings, the '${t}' parameter must start with 'http' (for cross-origin matches) or '/' (for same-origin matches). Please see the docs for ${r}.${e}() for more info.`},"channel-name-required":()=>"You must provide a channelName to construct a BroadcastCacheUpdate instance.","invalid-responses-are-same-args":()=>"The arguments passed into responsesAreSame() appear to be invalid. Please ensure valid Responses are used.","expire-custom-caches-only":()=>"You must provide a 'cacheName' property when using the expiration plugin with a runtime caching strategy.","unit-must-be-bytes":({normalizedRangeHeader:r})=>{if(!r)throw new Error("Unexpected input to 'unit-must-be-bytes' error.");return`The 'unit' portion of the Range header must be set to 'bytes'. The Range header provided was "${r}"`},"single-range-only":({normalizedRangeHeader:r})=>{if(!r)throw new Error("Unexpected input to 'single-range-only' error.");return`Multiple ranges are not supported. Please use a  single start value, and optional end value. The Range header provided was "${r}"`},"invalid-range-values":({normalizedRangeHeader:r})=>{if(!r)throw new Error("Unexpected input to 'invalid-range-values' error.");return`The Range header is missing both start and end values. At least one of those values is needed. The Range header provided was "${r}"`},"no-range-header":()=>"No Range header was found in the Request provided.","range-not-satisfiable":({size:r,start:e,end:t})=>`The start (${e}) and end (${t}) values in the Range are not satisfiable by the cached response, which is ${r} bytes.`,"attempt-to-cache-non-get-request":({url:r,method:e})=>`Unable to cache '${r}' because it is a '${e}' request and only 'GET' requests can be cached.`,"cache-put-with-no-response":({url:r})=>`There was an attempt to cache '${r}' but the response was not defined.`,"no-response":({url:r,error:e})=>{let t=`The strategy could not generate a response for '${r}'.`;return e&&(t+=` The underlying error is ${e}.`),t},"bad-precaching-response":({url:r,status:e})=>`The precaching request for '${r}' failed`+(e?` with an HTTP status of ${e}.`:"."),"non-precached-url":({url:r})=>`createHandlerBoundToURL('${r}') was called, but that URL is not precached. Please pass in a URL that is precached instead.`,"add-to-cache-list-conflicting-integrities":({url:r})=>`Two of the entries passed to 'workbox-precaching.PrecacheController.addToCacheList()' had the URL ${r} with different integrity values. Please remove one of them.`,"missing-precache-entry":({cacheName:r,url:e})=>`Unable to find a precached response in ${r} for ${e}.`,"cross-origin-copy-response":({origin:r})=>`workbox-core.copyResponse() can only be used with same-origin responses. It was passed a response with origin ${r}.`},b=(r,...e)=>{let t=r;return e.length>0&&(t+=` :: ${JSON.stringify(e)}`),t},$=(r,e={})=>{const t=messages[r];if(!t)throw new Error(`Unable to find message for code '${r}'.`);return t(e)},w=b;class d extends Error{constructor(e,t){const s=w(e,t);super(s);this.name=e,this.details=t}}const ce=(r,e)=>{if(!Array.isArray(r))throw new WorkboxError("not-an-array",e)},le=(r,e,t)=>{if(typeof r[e]!=="function")throw t.expectedMethod=e,new WorkboxError("missing-a-method",t)},ue=(r,e,t)=>{if(typeof r!==e)throw t.expectedType=e,new WorkboxError("incorrect-type",t)},he=(r,e,t)=>{if(!(r instanceof e))throw t.expectedClass=e,new WorkboxError("incorrect-class",t)},fe=(r,e,t)=>{if(!e.includes(r))throw t.validValueDescription=`Valid values are ${JSON.stringify(e)}.`,new WorkboxError("invalid-value",t)},de=(r,e,t)=>{const s=new WorkboxError("not-array-of-class",t);if(!Array.isArray(r))throw s;for(const n of r)if(!(n instanceof e))throw s},pe=null,S=null;var we=l("./node_modules/workbox-routing/_version.js");const q="GET",ge=null,v=r=>r&&typeof r=="object"?r:{handle:r};class C{constructor(e,t,s=q){this.handler=v(t),this.match=e,this.method=s}setCatchHandler(e){this.catchHandler=v(e)}}class me extends null{constructor(e,{allowlist:t=[/./],denylist:s=[]}={}){super(n=>this._match(n),e);this._allowlist=t,this._denylist=s}_match({url:e,request:t}){if(t&&t.mode!=="navigate")return!1;const s=e.pathname+e.search;for(const n of this._denylist)if(n.test(s))return!1;return!!this._allowlist.some(n=>n.test(s))}}class H extends C{constructor(e,t,s){const n=({url:o})=>{const a=e.exec(o.href);if(!!a&&!(o.origin!==location.origin&&a.index!==0))return a.slice(1)};super(n,t,s)}}const D=r=>new URL(String(r),location.href).href.replace(new RegExp(`^${location.origin}`),"");class j{constructor(){this._routes=new Map,this._defaultHandlerMap=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",e=>{const{request:t}=e,s=this.handleRequest({request:t,event:e});s&&e.respondWith(s)})}addCacheListener(){self.addEventListener("message",e=>{if(e.data&&e.data.type==="CACHE_URLS"){const{payload:t}=e.data,s=Promise.all(t.urlsToCache.map(n=>{typeof n=="string"&&(n=[n]);const o=new Request(...n);return this.handleRequest({request:o,event:e})}));e.waitUntil(s),e.ports&&e.ports[0]&&s.then(()=>e.ports[0].postMessage(!0))}})}handleRequest({request:e,event:t}){const s=new URL(e.url,location.href);if(!s.protocol.startsWith("http"))return;const n=s.origin===location.origin,{params:o,route:a}=this.findMatchingRoute({event:t,request:e,sameOrigin:n,url:s});let i=a&&a.handler;const u=[],k=e.method;if(!i&&this._defaultHandlerMap.has(k)&&(i=this._defaultHandlerMap.get(k)),!i)return;let m;try{m=i.handle({url:s,request:e,event:t,params:o})}catch(E){m=Promise.reject(E)}const y=a&&a.catchHandler;return m instanceof Promise&&(this._catchHandler||y)&&(m=m.catch(E=>c(this,null,function*(){if(y)try{return yield y.handle({url:s,request:e,event:t,params:o})}catch(re){E=re}if(this._catchHandler)return this._catchHandler.handle({url:s,request:e,event:t});throw E}))),m}findMatchingRoute({url:e,sameOrigin:t,request:s,event:n}){const o=this._routes.get(s.method)||[];for(const a of o){let i;const u=a.match({url:e,sameOrigin:t,request:s,event:n});if(u)return i=u,(Array.isArray(u)&&u.length===0||u.constructor===Object&&Object.keys(u).length===0||typeof u=="boolean")&&(i=void 0),{route:a,params:i}}return{}}setDefaultHandler(e,t=q){this._defaultHandlerMap.set(t,v(e))}setCatchHandler(e){this._catchHandler=v(e)}registerRoute(e){this._routes.has(e.method)||this._routes.set(e.method,[]),this._routes.get(e.method).push(e)}unregisterRoute(e){if(!this._routes.has(e.method))throw new d("unregister-route-but-not-found-with-method",{method:e.method});const t=this._routes.get(e.method).indexOf(e);if(t>-1)this._routes.get(e.method).splice(t,1);else throw new d("unregister-route-route-not-registered")}}let R;const F=()=>(R||(R=new j,R.addFetchListener(),R.addCacheListener()),R);function K(r,e,t){let s;if(typeof r=="string"){const o=new URL(r,location.href),a=({url:i})=>i.href===o.href;s=new C(a,e,t)}else if(r instanceof RegExp)s=new H(r,e,t);else if(typeof r=="function")s=new C(r,e,t);else if(r instanceof C)s=r;else throw new d("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});return F().registerRoute(s),s}function ye(r){getOrCreateDefaultRouter().setCatchHandler(r)}function _e(r){getOrCreateDefaultRouter().setDefaultHandler(r)}const g={googleAnalytics:"googleAnalytics",precache:"precache-v2",prefix:"workbox",runtime:"runtime",suffix:typeof registration!="undefined"?registration.scope:""},O=r=>[g.prefix,r,g.suffix].filter(e=>e&&e.length>0).join("-"),N=r=>{for(const e of Object.keys(g))r(e)},B={updateDetails:r=>{N(e=>{typeof r[e]=="string"&&(g[e]=r[e])})},getGoogleAnalyticsName:r=>r||O(g.googleAnalytics),getPrecacheName:r=>r||O(g.precache),getPrefix:()=>g.prefix,getRuntimeName:r=>r||O(g.runtime),getSuffix:()=>g.suffix};function W(r,e){const t=new URL(r);for(const s of e)t.searchParams.delete(s);return t.href}function I(r,e,t,s){return c(this,null,function*(){const n=W(e.url,t);if(e.url===n)return r.match(e,s);const o=U(P({},s),{ignoreSearch:!0}),a=yield r.keys(e,o);for(const i of a){const u=W(i.url,t);if(n===u)return r.match(i,s)}})}class G{constructor(){this.promise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}}const J=new Set;function Y(){return c(this,null,function*(){for(const r of J)yield r()})}function Q(r){return new Promise(e=>setTimeout(e,r))}var be=l("./node_modules/workbox-strategies/_version.js");function T(r){return typeof r=="string"?new Request(r):r}class V{constructor(e,t){this._cacheKeys={},Object.assign(this,t),this.event=t.event,this._strategy=e,this._handlerDeferred=new G,this._extendLifetimePromises=[],this._plugins=[...e.plugins],this._pluginStateMap=new Map;for(const s of this._plugins)this._pluginStateMap.set(s,{});this.event.waitUntil(this._handlerDeferred.promise)}fetch(e){return c(this,null,function*(){const{event:t}=this;let s=T(e);if(s.mode==="navigate"&&t instanceof FetchEvent&&t.preloadResponse){const a=yield t.preloadResponse;if(a)return a}const n=this.hasCallback("fetchDidFail")?s.clone():null;try{for(const a of this.iterateCallbacks("requestWillFetch"))s=yield a({request:s.clone(),event:t})}catch(a){throw new d("plugin-error-request-will-fetch",{thrownError:a})}const o=s.clone();try{let a;a=yield fetch(s,s.mode==="navigate"?void 0:this._strategy.fetchOptions);for(const i of this.iterateCallbacks("fetchDidSucceed"))a=yield i({event:t,request:o,response:a});return a}catch(a){throw n&&(yield this.runCallbacks("fetchDidFail",{error:a,event:t,originalRequest:n.clone(),request:o.clone()})),a}})}fetchAndCachePut(e){return c(this,null,function*(){const t=yield this.fetch(e),s=t.clone();return this.waitUntil(this.cachePut(e,s)),t})}cacheMatch(e){return c(this,null,function*(){const t=T(e);let s;const{cacheName:n,matchOptions:o}=this._strategy,a=yield this.getCacheKey(t,"read"),i=U(P({},o),{cacheName:n});s=yield caches.match(a,i);for(const u of this.iterateCallbacks("cachedResponseWillBeUsed"))s=(yield u({cacheName:n,matchOptions:o,cachedResponse:s,request:a,event:this.event}))||void 0;return s})}cachePut(e,t){return c(this,null,function*(){const s=T(e);yield Q(0);const n=yield this.getCacheKey(s,"write");if(!t)throw new d("cache-put-with-no-response",{url:D(n.url)});const o=yield this._ensureResponseSafeToCache(t);if(!o)return!1;const{cacheName:a,matchOptions:i}=this._strategy,u=yield self.caches.open(a),k=this.hasCallback("cacheDidUpdate"),m=k?yield I(u,n.clone(),["__WB_REVISION__"],i):null;try{yield u.put(n,k?o.clone():o)}catch(y){throw y.name==="QuotaExceededError"&&(yield Y()),y}for(const y of this.iterateCallbacks("cacheDidUpdate"))yield y({cacheName:a,oldResponse:m,newResponse:o.clone(),request:n,event:this.event});return!0})}getCacheKey(e,t){return c(this,null,function*(){if(!this._cacheKeys[t]){let s=e;for(const n of this.iterateCallbacks("cacheKeyWillBeUsed"))s=T(yield n({mode:t,request:s,event:this.event,params:this.params}));this._cacheKeys[t]=s}return this._cacheKeys[t]})}hasCallback(e){for(const t of this._strategy.plugins)if(e in t)return!0;return!1}runCallbacks(e,t){return c(this,null,function*(){for(const s of this.iterateCallbacks(e))yield s(t)})}*iterateCallbacks(e){for(const t of this._strategy.plugins)if(typeof t[e]=="function"){const s=this._pluginStateMap.get(t);yield o=>{const a=U(P({},o),{state:s});return t[e](a)}}}waitUntil(e){return this._extendLifetimePromises.push(e),e}doneWaiting(){return c(this,null,function*(){let e;for(;e=this._extendLifetimePromises.shift();)yield e})}destroy(){this._handlerDeferred.resolve()}_ensureResponseSafeToCache(e){return c(this,null,function*(){let t=e,s=!1;for(const n of this.iterateCallbacks("cacheWillUpdate"))if(t=(yield n({request:this.request,response:t,event:this.event}))||void 0,s=!0,!t)break;return s||t&&t.status!==200&&(t=void 0),t})}}class X{constructor(e={}){this.cacheName=B.getRuntimeName(e.cacheName),this.plugins=e.plugins||[],this.fetchOptions=e.fetchOptions,this.matchOptions=e.matchOptions}handle(e){const[t]=this.handleAll(e);return t}handleAll(e){e instanceof FetchEvent&&(e={event:e,request:e.request});const t=e.event,s=typeof e.request=="string"?new Request(e.request):e.request,n="params"in e?e.params:void 0,o=new V(this,{event:t,request:s,params:n}),a=this._getResponse(o,s,t),i=this._awaitComplete(a,o,s,t);return[a,i]}_getResponse(e,t,s){return c(this,null,function*(){yield e.runCallbacks("handlerWillStart",{event:s,request:t});let n;try{if(n=yield this._handle(t,e),!n||n.type==="error")throw new d("no-response",{url:t.url})}catch(o){for(const a of e.iterateCallbacks("handlerDidError"))if(n=yield a({error:o,event:s,request:t}),n)break;if(!n)throw o}for(const o of e.iterateCallbacks("handlerWillRespond"))n=yield o({event:s,request:t,response:n});return n})}_awaitComplete(e,t,s,n){return c(this,null,function*(){let o,a;try{o=yield e}catch(i){}try{yield t.runCallbacks("handlerDidRespond",{event:n,request:s,response:o}),yield t.doneWaiting()}catch(i){a=i}if(yield t.runCallbacks("handlerDidComplete",{event:n,request:s,response:o,error:a}),t.destroy(),a)throw a})}}const ke={strategyStart:(r,e)=>`Using ${r} to respond to '${D(e.url)}'`,printFinalResponse:r=>{r&&(S.groupCollapsed("View the final response here."),S.log(r||"[No response returned]"),S.groupEnd())}};class xe extends null{_handle(e,t){return c(this,null,function*(){const s=[];let n=yield t.cacheMatch(e),o;if(!n)try{n=yield t.fetchAndCachePut(e)}catch(a){o=a}if(!n)throw new WorkboxError("no-response",{url:e.url,error:o});return n})}}class Re extends null{_handle(e,t){return c(this,null,function*(){const s=yield t.cacheMatch(e);if(!s)throw new WorkboxError("no-response",{url:e.url});return s})}}const Z={cacheWillUpdate:e=>c(this,[e],function*({response:r}){return r.status===200||r.status===0?r:null})};class $e extends null{constructor(e={}){super(e);this.plugins.some(t=>"cacheWillUpdate"in t)||this.plugins.unshift(cacheOkAndOpaquePlugin),this._networkTimeoutSeconds=e.networkTimeoutSeconds||0}_handle(e,t){return c(this,null,function*(){const s=[],n=[];let o;if(this._networkTimeoutSeconds){const{id:u,promise:k}=this._getTimeoutPromise({request:e,logs:s,handler:t});o=u,n.push(k)}const a=this._getNetworkPromise({timeoutId:o,request:e,logs:s,handler:t});n.push(a);const i=yield t.waitUntil((()=>c(this,null,function*(){return(yield t.waitUntil(Promise.race(n)))||(yield a)}))());if(!i)throw new WorkboxError("no-response",{url:e.url});return i})}_getTimeoutPromise({request:e,logs:t,handler:s}){let n;return{promise:new Promise(a=>{n=setTimeout(()=>c(this,null,function*(){a(yield s.cacheMatch(e))}),this._networkTimeoutSeconds*1e3)}),id:n}}_getNetworkPromise(o){return c(this,arguments,function*({timeoutId:e,request:t,logs:s,handler:n}){let a,i;try{i=yield n.fetchAndCachePut(t)}catch(u){a=u}return e&&clearTimeout(e),(a||!i)&&(i=yield n.cacheMatch(t)),i})}}class ve extends null{constructor(e={}){super(e);this._networkTimeoutSeconds=e.networkTimeoutSeconds||0}_handle(e,t){return c(this,null,function*(){let s,n;try{const o=[t.fetch(e)];if(this._networkTimeoutSeconds){const a=timeout(this._networkTimeoutSeconds*1e3);o.push(a)}if(n=yield Promise.race(o),!n)throw new Error(`Timed out the network response after ${this._networkTimeoutSeconds} seconds.`)}catch(o){s=o}if(!n)throw new WorkboxError("no-response",{url:e.url,error:s});return n})}}class z extends X{constructor(e){super(e);this.plugins.some(t=>"cacheWillUpdate"in t)||this.plugins.unshift(Z)}_handle(e,t){return c(this,null,function*(){const s=[],n=t.fetchAndCachePut(e).catch(()=>{});let o=yield t.cacheMatch(e),a;if(!o)try{o=yield n}catch(i){a=i}if(!o)throw new d("no-response",{url:e.url,error:a});return o})}}const ee="static-cache-v2";self.__WB_DISABLE_DEV_LOGS=!0;const te=new Set(["font","manifest","paintworklet","script","sharedworker","style","worker"]);K(({request:r})=>te.has(r.destination),new z({cacheName:ee}))})()})();
